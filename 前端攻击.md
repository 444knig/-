http referer：
- 引荐人：告诉了服务器，用户在访问当前资源之前的位置
  - 主要三个常见：加载图片、点击网页上的链接、提交表单的时候
  - 不适合出现的时候：暴露内网地址，功能性URL
  - 不希望暴露域名，但可以暴露流量去向
- Rel属性
  - rel="noreferrer"：该元素发起HTTP请求时，不会带有referer头字段
  - Referrer Policy：可以选择发送的规则
    - 使用方法：服务器发送网页时，通过 HTTP 头信息的Referrer-Policy告诉浏览器。
    - 在CSP设置
    - 网页头部设置`<meta`属性
- 退出页面重定向
  - 链接时不直接跳转，而是转到一个过度地址，那么Referer字段就不会包含原始网址

CRSF:
- 几种攻击的常见类型：
  - GET类型：
    - `<img src="http://bank.example/withdraw?amount=10000&for=hacker" > `
    - 直接发送一次跨域请求
  - POST类型：
    - 访问该页面后，表单自动进行提交
  - 链接类型的CSRF
    - 点击链接后进行提交：
- CSRF的特点：
  - 攻击一般发起在第三方网站，被攻击的网站无法防止攻击发生。
  - 利用受害者在被攻击网站的登录凭证，冒充受害者提交操作
  - “冒充”操作，无法获取凭证
  - 跨站请求可以通过图片、URL、表单等，部分还可以自动嵌入在论坛、文章中进行
- 防护策略：
  - 只能从 增强自己网站对CSRF的能力进行防护
  - CSRF的两个特点：
    - 发生在第三方域名
    - 不能获取cookies等信息，知识利用
  - 针对第一点：
    - 阻止不明外域的访问
      - 同源检测
        - 首先判断是否来自外域：
        - 但是有两种情况不带有origin字段
          - IE11同源策略，与W3C指定的同源策略不同，而且11中，referer是唯一的标识
          - 302重定向：302重定向之后Origin不包含在重定向的请求中  origin是敏感信息，不想泄露
        - 接禁止外域发起请求
        - **因此 origin和referer字段都可能不可信或者不出现** 这是建议直接阻止，特别是没有使用随机CSRF Token的情况下
        - 但搜索引擎的get请求也很有可能被当作攻击，即使get情况不包括更新数据库，但还是有隐患
        - 
      - Samesite Cookie
        - Samesite=Strict。表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie
          - 在这种模式下，攻击者根本没机会
        - Samesite=Lax。假如这个请求改变了当前页面或者打开了新页面，且同时是个GET请求
        - 兼容性差：除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持
        - SamesiteCookie不支持子域的使用
          - 不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次
    - 提交时要求附加本域才能获取的信息
      - CSRF Token
        - 要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token
        - 将CSRF Token输出到页面中
          - DOM中所有的a和form标签后加入Token（之后动态产生的节点需要动态增加token）
          - 解密对比，字符串一致而且时间未过期
          - 优点：安全
          - 缺点：麻烦，写入多个标签，加大了动态网页渲染的负担。保证页面和session服务器的token一致，会造成不能在通用的拦截上统一拦截处理的后果。工作量巨大，且有可能遗漏
          - 验证码和密码充当CSRF token 更为常用
      - 双重Cookie验证
        - CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值
        - 优点：
          - 无需使用Session，适用面更广，易于实施。
          - Token储存于客户端中，不会给服务器带来压力 成本低
        - 缺点：
          - cookies增加了额外的字段
          - 如果一个子域名存在xss漏洞，修改了cookies，那么将失效
          - 为了确保cookies的传输安全，推荐使用https
  - 总结：
    - CSRF自动防御策略：同源检测（Origin 和 Referer 验证）
    - CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。
    - 保证页面的幂等性，后端接口不要在GET页面中做用户操作。
  - **看不懂的内容**：
    - 对于来自黑客自己的网站，我们无法防护。但对其他情况，那么如何防止自己的网站被利用成为攻击的源头呢？
      - 严格管理所有的上传接口，防止任何预期之外的上传内容（例如HTML）。
      - 添加Header X-Content-Type-Options: nosniff 防止黑客上传HTML内容的资源（例如图片）被解析为网页。
      - 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。
      - 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。

- XSS 攻击的介绍
  - 内嵌的文本中，恶意内容以 script 标签形成注入`<script> alert()<script/>`
    - escapeHTML() 按照规则转义
  - 内联的 JavaScript 中，拼接的数据突破了原本的限制 JavaScript:alert()
- 总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞
- 一些防护方法：
  - 对所有用户提交的内容进行可靠的验证输入，post keyword等限定长度 只接受预期，特殊子类一律转移
$$垃圾$$
#### 内存泄漏
- 不需要的内存没有正确的被收回
- 常见情况：
  - 意外的全局变量：未开启严格模式
  - 被遗忘的计时器或回调函数（循环引用）
  - 脱离 DOM 的引用和 DOM 树内部或子节点的引用问题（错误将DOM节点用额外的变量存储）


#### 开发工具
- 与内存相关的两个重要的工具：timeline 和 profiles
  - timeline 可以检测内存是否稳定的增长
  - Profiles：保存快照，对比 JavaScript 代码内存使用的不同快照
    - 展示了不同类型对象的分配及合计大小：shallow size（特定类型的所有对象的总大小），retained size（shallow size 加上其它与此关联的对象大小）。它还提供了一个概念，一个对象与关联的 GC root 的距离。
- 关于建连接时SYN超时:
  - 在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。
- 关于SYN Flood攻击：
  - 

#### 收回算法(v8)
- 根对象被定义为处于活跃状态，是浏览器或V8所引用的对象
  - 被局部变量所指向的对象属于根对象，因为它们的栈被视为根对象
  - 全局对象属于根对象，因为它们始终可被访问；
  - 浏览器对象，如DOM元素，也属于根对象，尽管在某些场合下它们只是弱引用。
- 判断标准：
  - 如果一个对象可经由某个被定义为活跃对象的对象，通过某个指针链所访问，则它就是活跃的。其他的都被视为垃圾。
- 堆得构成：
  - 新生区：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。
  - 老生指针区：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。
  - 老生数据区：这里存放只包含原始数据的对象，字符串、封箱的数字以及未封箱的双精度数字数组，在新生区存活一段时间后会被移动到这里。
  - 大对象区：这里存放体积超越其他区大小的对象。每个对象有自己mmap产生的内存。**垃圾回收器从不移动大对象。**
  - 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配到这里
    - 唯一拥有执行权限的内存区
    - 不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的，但大对象区并不是可执行的。
  - Cell区、属性Cell区、Map区：这些区域存放Cell、属性Cell和Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单
  - url(http://newhtml.net/v8-garbage-collection/)
- 如何识别指针和数据
  - 大多数垃圾回收算法会将对象在内存中挪动（以便减少内存碎片，使内存紧凑），因此即使不区分指针和数据，我们也常常需要对指针进行改写。
  - 目前有三种方法：
    - 保守法：对于缺少编译器支持的情况非常必要
      - 将所有堆上对齐的字都认为是指针，意味着有些数据也会被误认为是指针。
      - 于是某些实际是数字的假指针，会被误认为指向活跃的对象，则我们会时常出现一些奇异的内存泄漏
    - 编译器提示法：
      - 如果我们和静态语言打交道，则编译器能够准确地告诉我们每个类当中指针的具体位置
      - 只要知道对象是哪个类实例化得到的，我们就能知道对象中所有的指针
    - 标记指针法：
      - 需要在每个字的末位预留一位来标记这个字代表的是指针抑或数据
      - 需要一定的编译器支持，但实现简单，而且性能不俗（v8）
    - v8的实现细节：
      - *V8将所有属于-230…230-1范围内的小整数（V8内部称其为Smis）以32bit字宽来存储，其中的最低一位保持为0，而指针的最低两位则为01。由于对象以4字节对齐，因此这样表达指针没有任何问题。大多数对象所含有的只是一组标记后的字，因此垃圾回收可以进行的很快。而有些类型的对象，比如字符串，我们确定它只含有数据，因此无需标记。* 
- 分代回收
  - *脚本中，绝大多数对象的生存期很短，只有某些对象的生存期较长*
  - 将堆进行了分代：
  - 对象起初会被分配在新生区
    - 在新生区的内存分配非常容易：我们只需保有一个指向内存区的指针，不断根据新对象的大小对其进行递增即可。当该指针达到了新生区的末尾，就会有一次清理（小周期），清理掉新生区中不活跃的死对象
  - 对于活跃超过2个小周期的对象，则需将其移动至老生区
    - 老生区在标记－清除或标记－紧缩（大周期）的过程中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。至于足够多到底是多少，则根据老生区自身的大小和程序的动向来定。
  - V8中的清理过程为Scavenge算法，按照Cheney的算法实现
  - 算法描述：
    - 新生区被划分为两个等大的子区：出区、入区。绝大多数内存的分配都会在出区发生（但某些特定类型的对象，如可执行的代码对象是分配在老生区的），当出区耗尽时，我们交换出区和入区（这样所有的对象都归属在入区当中），然后将入区中活跃的对象复制至出区或老生区当中。在这时我们会对活跃对象进行紧缩，以便提升Cache的内存局部性，保持内存分配的简洁快速。*详细讲解url(https://segmentfault.com/a/1190000000440270)*
  - 写屏障：
    - 按照上面的描述，我们无法保证一个老生区的对象，该对象指向新生代，他不会被回收
    - 如果遍历一边老生区，违背了初衷，消耗太大
    - 解决方法：写屏障
      - 在写缓冲区中有一个列表，列表中记录了所有老生区对象指向新生区的情况。
      - 新对象诞生的时候，并不会有指向它的指针，而当有老生区中的对象出现指向新生区对象的指针时，我们便记录下来这样的跨区指向。
    - V8也有一些优化来降低写屏障带来的消耗：
      1. 大多数的脚本执行时间都是发生在Crankshaft当中的，而Crankshaft常常能静态地判断出某个对象是否处于新生区。对于指向这些对象的写操作，可以无需写屏障。（写屏障判断的优化）
      2. Crankshaft中新出现了一种优化，即在对象不存在指向它的非局部引用时，该对象会被分配在栈上。而一个栈上对象的相关写操作显然无需写屏障。（译注：新生区和老生区在堆上。）（减少写屏障的发生）
      3. “老→新”这样的情况相对较为少见，因此通过将“新→新”和“老→老”两种常见情况的代码做优化，可以相对提升多数情形下的性能。每个页都以1MB对齐，因此给定一个对象的内存地址，通过将低20bit滤除来快速定位其所在的页；而页头有相关的标识来表明其属于新生区还是老生区，因此通过判断两个对象所属的区域，也可以快速确定是否是“老→新”。(快速判断对象区域)  
      4. 一旦我们找到“老→新”的指针，我们就可以将其记录在写缓冲区的末端。经过一定的时间（写缓冲区满的时候），我们将其排序，合并相同的项目，然后再除去已经不符合“老→新”这一情形的指针。（合并-异步改写）
  - 新生代-对象的晋升：
    - 对象从From空间复制到To空间时，会检查它的**内存地址**来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中
    - 对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代

  - 老生代：
    - 老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多
    - 老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用Scavenge算法，浪费一半空间不说，复制如此大块的内存消耗时间将会相当长
    - V8在老生代中的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合
  - “标记－清除”算法与“标记－紧缩”算法
  - 这两种算法都包括两个阶段：标记阶段，清除或紧缩阶段。
  - “标记-清除”：
    - 标记：
      - 遍历堆中的所有对象，并标记那些活着的对象。
      - 在标记阶段，所有堆上的活跃对象都会被标记（bfs）
        - 每个内存页有一个用来标记对象的位图，位图中的每一位对应内存页中的一个字。这个位图需要占据一定的空间（32位下为3.1%，64位为1.6%）
        - 有两位用来标记对象的状态，这个状态一共有三种（所以要两位）——白，灰，黑：
        1. 如果一个对象为白对象，它还没未被垃圾回收器发现
        2. 如果一个对象为灰对象，它已经被垃圾回收器发现，但其邻接对象尚未全部处理
        3. 如果一个对象为黑对象，说明它不仅被垃圾回收器发现，其邻接对象也全部被处理完毕了

        - 初始时，全白，从根节点被遍历到的对象会变成灰色，被放入一个双端队列中
        - 标记阶段的每次循环，gc会取出队列的一个灰节点，染黑，将其邻接节点入列
          - 特别大的对象，可能会在处理时进行分片，防止双端队列溢出。
          - 如果双端队列溢出，则对象仍然会成为灰对象，并不会被放入队列中
        - 当所有对象为非黑即白，结束，否则队列为空时扫描，将灰对象入队
      
    - 清除和紧缩阶段都是以内存页为单位回收内存
      - 清除：
        - 只清除没有被标记的对象（会造成内存的不连续）
      - 整理：
        - 将清除阶段变为紧缩极端
        - 将活着的对象向内存区的一段移动，移动完成后直接清理掉边界外的内存，效率不高
        - 紧缩算法的大致过程
         > 对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块内存页，将该对象复制过去，并在碎片页中的该对象上写上新的内存地址。随后在迁出过程中，对象的旧地址将会被记录下来，在迁出结束后，V8会遍历所有它所记录的旧对象的地址，将其更新为新地址。由于标记过程中也记录了不同页之间的指针，这些指针在此时也会进行更新。如果一个页非常活跃，如其中有过多需要记录的指针，那么地址记录会跳过它，等到下一轮垃圾回收进行处理
  - 增量标记与惰性清理
    - 带来的问题：当一个堆很大而且有很多活跃对象时，标记-清除和标记-紧缩算法会执行的很慢。起初我研究V8时，垃圾回收所引发的500-1000毫秒的停顿并不少见
    - 增量标记
      - 允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中，在堆的大小达到一定的阈值时启用
      - 启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记
      - 深度优先搜索，并同样采用白灰黑机制来分类对象。
      - 让gc和js脚本工作交替进行，减少最大停顿时间
    - 但是增量标记可能带来黑-白这样的副作用：(对象族谱发生了变化)
      - 解决方法：
        - 使用写屏障记录“黑→白”指针，一旦发现，将黑-灰重新入列，所包含的指针就能得到再次扫描
    - 惰性清理：
      - 当标记完成后，所有的对象都已经被标记，不是死对象就是活对象，堆上多少空间格局已经确定。
      - 因此可以不必着急释放那些死对象所占用的空间，而延迟清理过程的执行。
      - 垃圾回收器可以根据需要逐一清理死对象所占用的内存页
    - *Google近期还新增了并行清理支持。由于脚本的执行线程不会再触及死对象，页的清理任务可以放在另一个单独的线程中进行并只需极少的同步工作。同样的支持工作也正在并行标记上开展着，但目前还处于早期试验阶段。*